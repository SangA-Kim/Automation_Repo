               #include "C:/VCAST/Environments/Git_Test/SourceFiles/ctypes.h"
               #include "c:/vcast/mingw/include/stdio.h"
               #include "C:/VCAST/Environments/Git_Test/SourceFiles/database.h"
               /* Allow 10 Parties to wait */
               static name_type WaitingList[10];
               static unsigned int WaitingListSize = 0;
               static unsigned int WaitingListIndex = 0;
               const struct order_type NULL_ORDER =
                     {NO_SOUP, NO_SALAD, NO_ENTREE, NO_DESSERT, NO_BEVERAGE};
               /*
                *  This function adds in the tax & tip and returns a new check total
                *  It will either use the tax passed in as a user parameter, or it will
                *  use the global variable (default_tax) if it is non-zero.
                *
                */
               static int log_err_cnt=0;
               static float state_tax = .03;
               static float default_tax = .05;
               int Add(int a, int b)
               {
1 0     ( )    Add
1 1              int sum = 0;
1 2              sum = a + b;
1 3              return sum;
               }
               float Add_Tax_Tip( float check_total, float sales_tax, float tip )
               {
                   float new_total, tax;
                   int log_err;
2 0     ( )    Add_Tax_Tip
2 1     ( )( )   if (sales_tax > 0)
                   {
2 2                tax = sales_tax;
                   }
                   else 
2 3     ( )( )     if (sales_tax == 0)
                   {
2 4                  tax = default_tax;
                   }
                   else
                   {
2 5                  tax = 0;
                   }
2 6              log_err = log_tax_receipts( tax*check_total );
2 7     ( )( )   if (log_err)
                   {
2 8                log_err_cnt++;
2 9                printf("\nError in Logging Tax Receipts\n");
                   }
2 10             new_total = check_total * (1 + tax + tip);
2 11             return( new_total );
               }
               /* This function will add a free dessert to specific orders based on the 
                  entree, salad, and beverage choice. */
               int Add_Included_Dessert(struct order_type* Order)
               {
                 static int rc;
3 0     ( )    Add_Included_Dessert
3 1              rc = 0; //Neither
3 2     ( )( )   if(Order->Entree == STEAK &&
                    Order->Salad == CAESAR &&
                    Order->Beverage == MIXED_DRINK)
                 {
3 3                rc = 1;
3 4                Order->Dessert = PIE;
                 }
                 else 
3 5     ( )( )     if(Order->Entree == LOBSTER &&
                         Order->Salad == GREEN &&
                         Order->Beverage == WINE)
                 {
3 6                  rc = 2;
3 7                  Order->Dessert = CAKE;
                 }
3 8              return(rc);
               }
               float Place_Order(table_index_type Table,
                               seat_index_type Seat,
                               struct order_type Order)
               {
                 struct table_data_type Table_Data;
                 struct table_data_type *Table_Bfr;
4 0     ( )    Place_Order
4 1              Table_Data = Get_Table_Record(Table);
4 2              Table_Data.Is_Occupied = v_true;
4 3              Table_Data.Number_In_Party = Table_Data.Number_In_Party + 1;
4 4              Table_Data.Order[Seat] = Order;
                 /* Add a free dessert in some cases */
4 5              Add_Included_Dessert(&Table_Data.Order[Seat]);
4 6              switch(Order.Entree)
                   {
4 7     ( )        case NO_ENTREE :
4 8                  break;
4 9     ( )        case STEAK :
4 10                 Table_Data.Check_Total = Table_Data.Check_Total + 14;
4 11                 break;
4 12    ( )        case CHICKEN :
4 13                 Table_Data.Check_Total = Table_Data.Check_Total + 10;
4 14                 break;
4 15    ( )        case LOBSTER :
4 16                 Table_Data.Check_Total = Table_Data.Check_Total + 18;
4 17                 break;
4 18    ( )        case PASTA :
4 19                 Table_Data.Check_Total = Table_Data.Check_Total + 12;
4 20                 break;
4 21    ( )        default:
4 22                 printf( "Invalid Entree: %d", Order.Entree);
4 23                 break;
                   }
4 24             Update_Table_Record(Table, Table_Data.Check_Total, Table_Data);
4 25             return (Table_Data.Check_Total);
               }
               int Clear_Table(table_index_type Table)
               {
                 struct table_data_type Table_Data;
                 seat_index_type Seat;
5 0     ( )    Clear_Table
5 1              Table_Data = Get_Table_Record(Table);
5 2              Table_Data.Is_Occupied = v_false;
5 3              Table_Data.Number_In_Party = 1;
5 4              printf("\nClear Table %d\n", Table);
5 5     ( )( )   for (Seat=0; Seat < 4; Seat++)
5 6                Table_Data.Order[Seat] = NULL_ORDER;
5 7              Table_Data.Check_Total = 0;
5 8              Update_Table_Record(Table, 0, Table_Data);
5 9              return 0;
               }
               float Get_Check_Total(table_index_type Table)
               {
                 struct table_data_type Table_Data;
6 0     ( )    Get_Check_Total
6 1              Table_Data = Get_Table_Record(Table);
6 2              return (Table_Data.Check_Total);
               }
               void Add_Party_To_Waiting_List(char* Name)
               {
7 0     ( )    Add_Party_To_Waiting_List
7 1              int i = 0;
7 2     ( )( )   if(WaitingListSize > 9)
7 3                WaitingListSize = 0;
7 4     ( )( )   while(Name && *Name) {
7 5                WaitingList[WaitingListSize][i++] = *Name;
7 6                Name++;
                 }
7 7              WaitingList[WaitingListSize++][i] = 0;
               }
               char* Get_Next_Party_To_Be_Seated(void)
               {
8 0     ( )    Get_Next_Party_To_Be_Seated
8 1     ( )( )   if(WaitingListIndex > 9)
8 2                WaitingListIndex = 0;
8 3              return WaitingList[WaitingListIndex++];
               }
